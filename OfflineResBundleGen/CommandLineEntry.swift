//===---*- Greatdori! -*---------------------------------------------------===//
//
// CommandLineEntry.swift
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.com/LICENSE.txt for license information
// See https://greatdori.com/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

import DoriKit
import Foundation
import ArgumentParser

@main
struct CommandLineEntry: AsyncParsableCommand {
    @Flag
    var locale: LocaleFlag = .all
    @Option(name: .shortAndLong, help: "Output path, should be a directory.", transform: URL.init(fileURLWithPath:))
    var output: URL
    @Option
    var maxConnectionCount: Int = 100
    @Option(name: .shortAndLong, help: "The Github token used to upload data.")
    var token: String? = nil
    @Option(name: .shortAndLong, help: "The LastID used to fetch updates. Temporary use only.")
    var lastID: Int? = nil
    mutating func run() async throws {
        var isDirectory: ObjCBool = false
        if !FileManager.default.fileExists(atPath: output.path(percentEncoded: false), isDirectory: &isDirectory) {
            try FileManager.default.createDirectory(at: output, withIntermediateDirectories: true)
        } else if !isDirectory.boolValue {
            print("error: output path is not a directory", to: &stderr)
            Foundation.exit(EXIT_FAILURE)
        }
        
        LimitedTaskQueue.shared = .init(limit: maxConnectionCount)
        
        if locale == .all {
            await generateAPI(to: output)
            try await generate(to: output)
            // Dori resource should be generated by a separated run,
            // that is it's not covered by `.all`.
        } else if locale == .api {
            await generateAPI(to: output)
        } else if locale == .doriResource {
            try await generateDoriResource(to: output)
        } else if locale == .strandMain {
            await updateAssets(in: output, withToken: token, lastID: lastID)
        } else if locale == .debug {
            print("[$][DEBUG] Start Debug Process")
            await debugProcess(output: output, token: token, lastID: lastID)
        } else {
            print("Generating for \(locale.rawValue.uppercased())...\n")
            let localizedOutput = output.appending(path: locale.rawValue)
            if !FileManager.default.fileExists(atPath: localizedOutput.path(percentEncoded: false)) {
                try FileManager.default.createDirectory(at: localizedOutput, withIntermediateDirectories: true)
            }
            try await generateLocale(locale.apiLocale, to: localizedOutput)
        }
    }
    
    enum LocaleFlag: String, EnumerableFlag {
        case api
        case all
        case jp
        case en
        case tw
        case cn
        case kr
        case doriResource
        case debug
        case strandMain
        
        var apiLocale: DoriAPI.Locale {
            switch self {
            case .en: .en
            case .tw: .tw
            case .cn: .cn
            case .kr: .kr
            default: .jp
            }
        }
    }
}

func debugProcess(output: URL, token: String?, lastID: Int?) async {
    do {
        let note = await DoriAPI.News.Item(id: 8563)!.content
        print("[$][DEBUG] Note #8563 gotten.")
        let allPendingAssets = getDatasInAseetPatchNotes(from: note)
        print("[$][DEBUG] Assets gotten with total of \(allPendingAssets.count) item(s).")
        print("[$][DEBUG] Start Update")
        await updateLocale(datas: allPendingAssets, forLocale: .jp, to: output, withToken: token ?? "", lastIDs: (8563, 8563))
        print("[$][DEBUG] All Update Finished")
    } catch {
        print("updateAssets failure: \(error)")
    }
}
