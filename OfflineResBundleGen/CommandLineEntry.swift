//===---*- Greatdori! -*---------------------------------------------------===//
//
// CommandLineEntry.swift
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.com/LICENSE.txt for license information
// See https://greatdori.com/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

import SekaiKit
import Foundation
import ArgumentParser

@main
struct CommandLineEntry: AsyncParsableCommand {
    @Flag
    var locale: LocaleFlag = .all
    @Option(name: .shortAndLong, help: "Output path, should be a directory.", transform: URL.init(fileURLWithPath:))
    var output: URL
    @Option
    var maxConnectionCount: Int = 100
    @Option(name: .shortAndLong, help: "The Github token used to upload data.")
    var token: String? = nil
    @Option(name: .shortAndLong, help: "The LastID used to fetch updates. Temporary use only.")
    var lastID: Int? = nil
    mutating func run() async throws {
        var isDirectory: ObjCBool = false
        if !FileManager.default.fileExists(atPath: output.path(percentEncoded: false), isDirectory: &isDirectory) {
            try FileManager.default.createDirectory(at: output, withIntermediateDirectories: true)
        } else if !isDirectory.boolValue {
            print("error: output path is not a directory", to: &stderr)
            Foundation.exit(EXIT_FAILURE)
        }
        
        LimitedTaskQueue.shared = .init(limit: maxConnectionCount)
        
        if locale == .all {
            await generateAPI(to: output)
            try await generate(to: output)
            // Sekai resource should be generated by a separated run,
            // that is it's not covered by `.all`.
        } else if locale == .api {
            await generateAPI(to: output)
        } else if locale == .doriResource {
            try await generateSekaiResource(to: output)
        } else if locale == .strandMain {
            // Update All Assets (does not include API).
            await updateAssets(in: output, withToken: token, lastID: lastID)
        } else if locale == .debug {
            print("[$][DEBUG] Start Debug Process")
            await debugProcess(output: output, token: token, lastID: lastID)
        } else {
            print("Generating for \(locale.rawValue.uppercased())...\n")
            let localizedOutput = output.appending(path: locale.rawValue)
            if !FileManager.default.fileExists(atPath: localizedOutput.path(percentEncoded: false)) {
                try FileManager.default.createDirectory(at: localizedOutput, withIntermediateDirectories: true)
            }
            try await generateLocale(locale.apiLocale, to: localizedOutput)
        }
    }
    
    enum LocaleFlag: String, EnumerableFlag {
        case api
        case all
        case jp
        case en
        case tw
        case cn
        case kr
        case doriResource
        case debug
        case strandMain
        
        var apiLocale: SekaiAPI.Locale {
            switch self {
            case .en: .en
            case .tw: .tw
            case .cn: .cn
            case .kr: .kr
            default: .jp
            }
        }
    }
}

func debugProcess(output: URL, token: String?, lastID: Int?) async {
    do {
        let note = await SekaiAPI.News.Item(id: 8563)!.content
        print("[$][DEBUG] Note #8563 gotten.")
        let allPendingAssets = getDatasInAseetPatchNotes(from: note)
        print("[$][DEBUG] Assets gotten with total of \(allPendingAssets.count) item(s).")
        print("[$][DEBUG] Start Update")
        
        let locale: SekaiLocale = .jp
        let destination = output
        let token = token ?? ""
        
        // I. Initiailzization
        print("[$][Update][\(locale.rawValue)] Update process starts.")
        var groupedDatas: [String: [String]] = [:]
        
        // II. Divide Data in Groups
        for data in allPendingAssets {
            let branch = analyzePathBranch(data)
            groupedDatas.updateValue((groupedDatas[branch] ?? []) + [data], forKey: branch)
        }
        
        groupedDatas.removeValue(forKey: "basic")
        groupedDatas.removeValue(forKey: "movie")
        groupedDatas.removeValue(forKey: "unsupported")
        
        print("[$][Update][\(locale.rawValue)] \(groupedDatas.count) branch(es) requires update.")
        
        // III. Handle Grouped Datas
        for (branch, datas) in groupedDatas {
            do {
                // 0. Initialization
                print("[$][Update][\(locale.rawValue)/\(branch)] Started with \(datas.count) item(s).")
                let startTime = CFAbsoluteTimeGetCurrent()
                var updatedItemsCount = 0
                fflush(stdout)
                
                var gitBranch = "\(locale.rawValue)/\(branch)"
                if branch == "shared" {
                    gitBranch = branch
                    print("[$][Update][\(locale.rawValue)/\(branch)] This is a shared branch. Git branch changed to 'shared'")
                }
                
                // 1. Pull
                let script = #"""
echo "[%][Git Pull][\#(locale.rawValue)/\#(branch)] Pull process starts."

git config --global --add safe.directory "\#(destination.absoluteString.dropURLPrefix())"
cd "\#(destination.absoluteString.dropURLPrefix())"

echo "[%][Git Pull][\#(locale.rawValue)/\#(branch)] Directory set to \#(destination.absoluteString.dropURLPrefix())."

git checkout "\#(gitBranch)"

echo "[%][Git Pull][\#(locale.rawValue)/\#(branch)] Checked out."

# Retry git pull --rebase up to 10 times
for i in {1..10}; do
  if git pull --rebase; then
    break
  fi
done

echo "[%][Git Pull][\#(locale.rawValue)/\#(branch)] Git pulled."
"""#
                let (status, output) = try await runBashScript(script, commandName: "Git Pull", viewFailureAsFatalError: true)
                print("[✓][Update][\(locale.rawValue)/\(branch)] Git pulled. Status \(status).")
                fflush(stdout)
                
                // 2. Update Files
                LimitedTaskQueue.shared.addTask {
                    await withTaskGroup { group in
                        for data in datas {
                            group.addTask {
                                await updateFile(for: data, into: destination, inLocale: locale, onUpdate: { message in
                                    updatedItemsCount += 1
                                    printProgressBar(
                                        updatedItemsCount,
                                        total: datas.count,
                                        message: "\(message) \(formatSeconds(Int(CFAbsoluteTimeGetCurrent() - startTime)))")
                                })
                            }
                        }
                    }
                }
                await LimitedTaskQueue.shared.waitUntilAllFinished()
                fflush(stdout)
                
                // 3. Push
                do {
                    let script = #"""
echo "[%][Git Push][\#(locale.rawValue)/\#(branch)] Push script starts."
git config --global --add safe.directory "\#(destination.absoluteString.dropURLPrefix())"
cd "\#(destination.absoluteString.dropURLPrefix())"

echo "[%][Git Push][\#(locale.rawValue)/\#(branch)] Directory set to \#(destination.absoluteString.dropURLPrefix())."

git config user.name "Togawa Sakiko"
git config user.email "sakiko@darock.top"
\#(!token.isEmpty ? "git remote set-url origin https://x-access-token:\(token)@github.com/Greatdori/Greatdori-OfflineResBundle.git" : "")

echo "[%][Git Push][\#(locale.rawValue)/\#(branch)] Github user verification set."

git checkout "\#(gitBranch)"

echo "[%][Git Push][\#(locale.rawValue)/\#(branch)] Checked out."

git add .
git commit -m "Auto update \#(locale.rawValue)/\#(branch) ($(date +"%Y-%m-%d")) (#\#(8563))" || true
for i in {1..10}; do git push \#(!token.isEmpty ? "origin" : "ssh") && break; done

echo "[%][Git Push][\#(locale.rawValue)/\#(branch)] Commited & Pushed."
"""#
                    let (status, output) = try await runBashScript(script, commandName: "Git Push", viewFailureAsFatalError: true)
                    print("[✓][Update][\(locale.rawValue)/\(branch)] Git pushed. Status \(status).")
                    fflush(stdout)
                } catch {
                    print("[×][Update][\(locale.rawValue)/\(branch)] Git push failed. Error: \(error).")
                }
            } catch {
                print("[×][Update][\(locale.rawValue)/\(branch)] Git pull failed. Error: \(error).")
            }
        }
        print("[$][Update][\(locale.rawValue)] Update process ended.")
        
        print("[$][DEBUG] All Update Finished")
    } catch {
        print("updateAssets failure: \(error)")
    }
}
