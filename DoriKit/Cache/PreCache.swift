//===---*- Greatdori! -*---------------------------------------------------===//
//
// PreCache.swift
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.com/LICENSE.txt for license information
// See https://greatdori.com/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

import Foundation

extension DoriCache {
    // Generated by BuildTool/PreCacheGen
    /// A built-in cache for information that updates less frequently.
    ///
    /// To make it faster to get some data which is updated less frequent,
    /// DoriKit generates a `PreCache.cache` file in **compile-time**
    /// and embeds it to `DoriKit.framework` bundle. This allows you to get some information
    /// like character list from `DoriCache.preCache` without performing a network request.
    public struct PreCache: Sendable, Hashable, Decodable {
        public static let current: Self = preCache
        
        public var bands: [_DoriAPI.Bands.Band]
        public var mainBands: [_DoriAPI.Bands.Band]
        public var characters: [_DoriAPI.Characters.PreviewCharacter]
        public var birthdayCharacters: [_DoriAPI.Characters.BirthdayCharacter]
        public var categorizedCharacters: _DoriFrontend.Characters.CategorizedCharacters
        public var characterDetails: [Int: _DoriAPI.Characters.Character] // [CharacterID: Detail]
        
        public static var isAvailable: Bool {
#if DORIKIT_ENABLE_PRECACHE
            true
#else
            false
#endif
        }
    }
    
    /// Get a ``PreCache``.
    @inline(never)
    public static let preCache: PreCache = {
        #if DORIKIT_ENABLE_PRECACHE
        let decoder = PropertyListDecoder()
        let result = try! decoder.decode(PreCache.self, from: Data(contentsOf: #bundle.url(forResource: "PreCache", withExtension: "cache")!))
        //           ~~~^ If it traps here, re-generate you pre-cache!
        return result
        #else
        .init(bands: [], mainBands: [], characters: [], birthdayCharacters: [], categorizedCharacters: [:], characterDetails: [:])
        #endif
    }()
    
    internal static func preCachedData(byID id: String) -> Any? {
        switch id {
        case "CharacterList": preCache.categorizedCharacters
        case "Home_Birthdays": preCache.birthdayCharacters
        case let x where x.hasPrefix("CharacterDetail_"):
            if let characterID = Int(String(x.dropFirst("CharacterDetail_".count))) {
                preCache.characterDetails[characterID]
            } else {
                nil
            }
        default: nil
        }
    }
}
