//===---*- Greatdori! -*---------------------------------------------------===//
//
// DriverTopLevelTypes.swift
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.com/LICENSE.txt for license information
// See https://greatdori.com/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

// MARK: - API

// MARK: Basic Types
public typealias DoriLocale = DoriAPI.Locale
public typealias LocalizedData = DoriAPI.LocalizedData
public typealias Constellation = DoriAPI.Constellation
public typealias Attribute = DoriAPI.Attribute

// MARK: Login Campaign
public typealias LoginCampaign = DoriAPI.LoginCampaigns.Campaign
public typealias PreviewLoginCampaign = DoriAPI.LoginCampaigns.PreviewCampaign

extension LoginCampaign {
    @inlinable
    public static func all() async -> [PreviewLoginCampaign]? {
        await DoriAPI.LoginCampaigns.all()
    }
}
extension PreviewLoginCampaign {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.LoginCampaigns.all()
    }
}

// MARK: News
public typealias NewsItem = DoriAPI.News.Item
public typealias PreviewNewsItem = DoriAPI.News.PreviewItem
public typealias RecentNewsItems = DoriAPI.News.RecentItems

extension NewsItem {
    @inlinable
    public static func all() async -> [PreviewNewsItem]? {
        await DoriAPI.News.all()
    }
}
extension PreviewNewsItem {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.News.all()
    }
}
extension RecentNewsItems {
    @inlinable
    public static func all() async -> Self? {
        await DoriAPI.News.recent()
    }
}

// MARK: Types with preview
%{
    baseNames = ["Costume", "Event", "Gacha", "Song"]
}%
% for baseName in baseNames:
public typealias ${baseName} = DoriAPI.${baseName}s.${baseName}
public typealias Preview${baseName} = DoriAPI.${baseName}s.Preview${baseName}

extension ${baseName} {
    @inlinable
    public static func all() async -> [Preview${baseName}]? {
        await DoriFrontend.${baseName}s.list()
    }
}
extension Preview${baseName} {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriFrontend.${baseName}s.list()
    }
}
% end

// MARK: Types without preview
%{
    baseNames = ["Band", "Comic", "Degree", "Skill", "MiracleTicket"]
}%
% for baseName in baseNames:
public typealias ${baseName} = DoriAPI.${baseName}s.${baseName}

extension ${baseName} {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.${baseName}s.all()
    }
}
% end

// MARK: Band
extension Band {
    @inlinable
    public static func main() async -> [Self]? {
        await DoriAPI.Bands.main()
    }
}

// MARK: Card
public typealias Card = DoriAPI.Cards.Card
public typealias PreviewCard = DoriAPI.Cards.PreviewCard
public typealias CardType = DoriAPI.Cards.CardType
public typealias CardEpisode = DoriAPI.Cards.CardEpisode
public typealias CardStat = DoriAPI.Cards.CardStat

extension Card {
    @inlinable
    public static func all() async -> [PreviewCard]? {
        await DoriAPI.Cards.all()
    }
    
    @inlinable
    public static func allWithBand() async -> [CardWithBand]? {
        await DoriFrontend.Cards.list()
    }
}
extension PreviewCard {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.Cards.all()
    }
    
    @inlinable
    public static func allWithBand() async -> [CardWithBand]? {
        await DoriFrontend.Cards.list()
    }
}

// MARK: Character
public typealias Character = DoriAPI.Characters.Character
public typealias PreviewCharacter = DoriAPI.Characters.PreviewCharacter
public typealias BirthdayCharacter = DoriAPI.Characters.BirthdayCharacter
public typealias CategorizedCharacters = DoriFrontend.Characters.CategorizedCharacters

extension Character {
    @inlinable
    public static func all() async -> [PreviewCharacter]? {
        await DoriAPI.Characters.all()
    }
    
    @inlinable
    public static func categorized() async -> CategorizedCharacters? {
        await DoriFrontend.Characters.categorizedCharacters()
    }
}
extension PreviewCharacter {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.Characters.all()
    }
    
    @inlinable
    public static func categorized() async -> CategorizedCharacters? {
        await DoriFrontend.Characters.categorizedCharacters()
    }
}
extension BirthdayCharacter {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriAPI.Characters.allBirthday()
    }
}

// MARK: - Frontend

public typealias DoriFilter = DoriFrontend.Filter
public typealias DoriFilterable = DoriFrontend.Filterable
public typealias DoriSorter = DoriFrontend.Sorter
public typealias DoriSortable = DoriFrontend.Sortable
public typealias DoriSearchable = DoriFrontend.Searchable
public typealias DoriURLValidator = DoriFrontend.URLValidator

%{
    baseNames = ["Card", "Character", "Costume", "Event", "Gacha", "Song"]
}%
% for baseName in baseNames:
public typealias Extended${baseName} = DoriFrontend.${baseName}s.Extended${baseName}
% end

public typealias CardWithBand = DoriFrontend.Cards.CardWithBand

extension BirthdayCharacter {
    @inlinable
    public static func recent() async -> [Self]? {
        await DoriFrontend.Characters.recentBirthdayCharacters()
    }
}

extension CategorizedCharacters {
    @inlinable
    public static func all() async -> CategorizedCharacters? {
        await DoriFrontend.Characters.categorizedCharacters()
    }
}

extension Event {
    @inlinable
    public static func localizedLatest() async -> LocalizedData<PreviewEvent>? {
        await DoriFrontend.Events.localizedLatestEvent()
    }
}
extension PreviewEvent {
    @inlinable
    public static func localizedLatest() async -> LocalizedData<Self>? {
        await DoriFrontend.Events.localizedLatestEvent()
    }
}

public typealias NewsListItem = DoriFrontend.News.ListItem
public typealias NewsListFilter = DoriFrontend.News.ListFilter

extension NewsListItem {
    @inlinable
    public static func all(filter: NewsListFilter? = nil) async -> [Self]? {
        await DoriFrontend.News.list(filter: filter)
    }
}

public typealias ExtendedMiracleTicket = DoriFrontend.MiracleTickets.ExtendedMiracleTicket

extension ExtendedMiracleTicket {
    @inlinable
    public static func all() async -> [Self]? {
        await DoriFrontend.MiracleTickets.extendedList()
    }
}

// MARK: - Cache
public typealias DoriCacheable = DoriCache.Cacheable
public typealias PreCache = DoriCache.PreCache
public typealias CachePromise = DoriCache.Promise
public typealias CacheTrait = DoriCache.CacheTrait

/// Get result with automatic cache.
///
/// - Parameters:
///   - id: A unique identifier for cache.
///   - trait: Trait of data being cached, see ``CacheTrait`` for more details.
///   - invocation: A closure that returns a result that can be cached.
/// - Returns: A ``Promise`` for result.
///
/// Call this function with an identifier to get a promise for result,
/// then register an `onUpdate` closure for receiving new data:
/// ```swift
/// withDoriCache(id: "CacheID") {
///     await DoriAPI.Character.Character(id: 39)
/// }.onUpdate {
///     let myFavoriteCharacter = $0
/// }
/// ```
///
/// The `onUpdate` closure registered to a promise may be called more than once
/// (we call this *return twice*).
///
/// If a cache is available on disk, the promise will be update immediately,
/// which allows you to get data faster. Then if `invocation` returns a result
/// other than `nil`, the promise will be update again with the latest data from `invocation`.
///
/// If a cache is available on disk but `invocation` returns `nil`, the promise
/// will be update only once with data from cache, and cache on disk won't be update.
/// If cache is unavailable and `invocation` returns `nil`, the promise will be updated
/// with `nil`.
///
/// The mechanism above implies the promise will be update **at least once**
/// and may **more than once**.
///
/// - Note:
///     You can use the same ID in different places if the result types aren't same.
///     Caches with the same ID but different types will be stored separately.
@inline(__always)
public func withDoriCache<Result: Sendable & DoriCacheable>(
    id: String,
    trait: CacheTrait = .invocationElidable,
    invocation: sending @escaping () async -> Result?
) -> CachePromise<Result?> {
    DoriCache.withCache(id: id, trait: trait, invocation: invocation)
}

public typealias PreloadDescriptor = DoriCache.PreloadDescriptor

/// Preloads a resource for later usage.
///
/// - Parameter closure: A closure that returns the resource needed.
/// - Returns: A descriptor for this preloading.
///
/// You can get resource in any method in this closure, and return a result.
/// The closure provided will be performed quickly
/// after calling this function.
///
/// You need to keep the reference of the returned descriptor.
/// If it loses reference, the preloading task will be cancelled.
///
/// When you need the resource, use the ``PreloadDescriptor/value``
/// variable of descriptor to get the resource.
/// This variable gives you the resource immediately
/// if it has already finished preloading, or it will wait
/// until the resource becomes available.
///
/// ```swift
/// let preload = preload {
///     return await getMyResource()
/// }
///
/// // Do something another...
///
/// doSomething(withResource: await preload.value)
/// ```
///
/// When working with DoriKit networking, you can use
/// ``withPreloaded(_:isolation:operation:)``
/// to provide descriptors for all requests in a closure.
///
/// ```swift
/// let preloadCharacters = preload {
///     await Character.all()
/// }
/// let preloadBands = preload {
///     await Band.main()
/// }
///
/// // Do something another...
///
/// withPreloaded(preloadCharacters, preloadBands) {
///     // The two requests below are actually started
///     // when you call `preload` before.
///     let characters = await Character.all()
///     let bands = await Band.main()
/// }
/// ```
@inline(__always)
public func preload<T: Sendable>(_ closure: sending @escaping () async -> T?) -> PreloadDescriptor<T> {
    DoriCache.preload(closure)
}
@inline(__always)
public func withPreloaded<each T, Result>(
    _ descriptors: repeat PreloadDescriptor<each T>?,
    isolation: isolated (any Actor)? = #isolation,
    operation: () async throws -> Result
) async rethrows -> Result {
    try await DoriCache.withPreloaded(repeat each descriptors, isolation: isolation, operation: operation)
}
